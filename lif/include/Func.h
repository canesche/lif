//===-- Func.h --------------------------------------------------*- C++ -*-===//
// Copyright (C) 2020  Luigi D. C. Soares
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//===----------------------------------------------------------------------===//
///
/// \file
/// This file contains function-related types and functions used by the
/// isochronous pass.
///
//===----------------------------------------------------------------------===//
#ifndef LIF_FUNC_H
#define LIF_FUNC_H

#include "Cond.h"
#include "Loop.h"

#include <llvm/ADT/DenseMap.h>
#include <llvm/ADT/SmallPtrSet.h>
#include <llvm/Analysis/TargetLibraryInfo.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/Instruction.h>
#include <llvm/IR/Instructions.h>
#include <llvm/IR/PassManager.h>

#include <memory>

namespace lif {
/// A wrapper for a function F to indicate whether it is derived or not. By
/// derived we mean that F is called directly or indirectly by another function
/// G. We also store both the map of incoming and outgoing conditions (see
/// Cond.h), a loop wrapper (see Loop.h) and instructions that shall be skipped
/// by the isochronous pass.
struct FuncWrapper {
    /// The wrapped function.
    llvm::Function &F;
    /// Indicates that the wrapped function is derived, i.e. it is called
    /// by some other function that will be transformed.
    bool IsDerived;
    /// Map of outgoing conditions for each basic block.
    OutMap OM;
    /// Map of incoming conditions for each basic block.
    InMap IM;
    /// Load/Store instructions generated by the data-flow analysis that bind
    /// conditions to each basic block, which does not need to be transformed.
    llvm::SmallPtrSet<llvm::Instruction *, 32> Skip;
    /// A wrapper to extend informations about loops.
    std::unique_ptr<LoopWrapper> LW;
    /// Takes a function \p F and produces a wrapper to extend \p F with useful
    /// information.
    FuncWrapper(llvm::Function &F, bool IsDerived)
        : F(F), IsDerived(IsDerived) {}
};

using LenMap = llvm::DenseMap<llvm::Value *, llvm::Value *>;
/// Traverses the list of arguments of \p F to match each pointer with its
/// length. Also infers the length of local pointers.
///
/// \returns A map between a value and its length.
LenMap computeLength(llvm::Function &F, const llvm::TargetLibraryInfo *TLI);

/// Given two values, \p VTrue and \p VFalse, and a condition \p Cond,
/// generate instructions for selecting between \p VTrue and \p VFalse.
///
/// We use LLVM select inst. assuming that it is going to be lowered to a
/// constant-time inst. (e.g. cmov on x86). However, it can be manually
/// implemented as ctsel(cond, vtrue, vfalse) = { c = cond - 1; c' = ~c; v
/// = (c & vfalse) | (c' & vtrue) }
///
/// \returns a value representing the selected one.
llvm::Value *ctsel(llvm::Value *Cond, llvm::Value *VTrue, llvm::Value *VFalse,
                   llvm::Instruction *Before);

/// Transforms \p GEP into a set of instructions according to \p Cond and \p
/// PtrLen.
///
/// \returns The llvm value representing the select between GEP and Shadow.
llvm::Value *transformGEP(llvm::GetElementPtrInst *GEP,
                          llvm::AllocaInst *Shadow, llvm::Value *PtrLen,
                          llvm::Value *Cond, llvm::Instruction *Before);

/// Transforms \p Load into a set of instructions according to the outgoing
/// condition of the basic block (i.e. the fold of the incoming conds.) that
/// contains \p Load.
void transformLoad(llvm::LoadInst &Load, llvm::AllocaInst *Shadow,
                   llvm::Value *PtrLen, llvm::Value *Cond);

/// Transforms \p Store into a set of instructions according to the incoming
/// conditions of the basic block that contains \p Store.
void transformStore(llvm::StoreInst &Store, llvm::AllocaInst *Shadow,
                    llvm::Value *PtrLen, llvm::Value *Cond);

/// Transforms \p Phi into a set of instructions according to the incoming
/// conditions of the basic block that contains \Phi.
///
/// Note: If the transformation occurs, \p Phi is removed from the basic
/// block.
void transformPhi(llvm::PHINode &Phi,
                  const llvm::SmallVectorImpl<Incoming> &Incomings);

/// Transforms \p P (the definition of some predicate used in a branch inside a
/// loop) in a way that it respects the associated \p Phi. That is, whenever
/// \p P becomes true, it cannot change back to false.
void transformPredAssign(llvm::Instruction &P, llvm::PHINode &Phi);

/// Transform \p F into isochronous by applying the proper rules to each
/// instruction.
void transformFunc(FuncWrapper *FW, llvm::FunctionAnalysisManager &FAM);

/// Takes a function \p F and unify its exit points into a single one.
void unifyExits(llvm::Function &F);

/// Takes a function \p F, computes the path conditions, unifies the exit
/// points and wrap everything together into a single structure.
///
/// \returns The wrapped function.
FuncWrapper wrapFunc(llvm::Function &F, bool IsDerived,
                     llvm::FunctionAnalysisManager &FAM);
} // namespace lif

#endif
