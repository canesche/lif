#!/usr/bin/env bash

source yaml.sh

# Take the path to a cachegrind file generated by cg_annotate, and the
# function to be processed, and extract the general stats about it.
cachegrind::process_fn() {
    local cg=$1
    local fn=$2

    sed -n "/:${fn}$/ s/\/.*//p" ${cg} \
        | sed "s/([^)]*)//g" \
        | sed "s/^[[:blank:]]*//" \
        | sed "s/[[:blank:]]*$//" \
        | sed "s/,/./g" \
        | sed -E "s/[[:blank:]]+/,/g"
}

# Takes the path to a benchmark and filter the cachegrind stats collected by
# cachegrind::run to produce CSV files containing the results for specific
# functions. This function assumes the existence of three cachegrind files
# (generated by cg_annotate) for each source file (original, invariant and
# invar-optimized).
cachegrind::filter() {
    local bench=$1;

    local results=${bench}/results
    local sources=${bench}/sources

    # Parse the bench/meta.yaml file to get the name of the functions and
    # the sources
    local -A meta
    yaml::parse ${bench}/meta.yaml meta
    local -a srcs=(${meta[sources]//,/ })
    local -a fns=(${meta[functions]//,/ })
    local -a libs=(${meta[libs]//,/ })
    local -a cache=($(echo ${meta[cache]//,/ } | sed "s/;/,/g"))

    # We assume that the collected evens are the same for all sources, so we
    # can take them from cachegrind file related to the first source.
    local cg=${results}/$(echo ${srcs[0]} | sed "s/\.[^.]*$//")
    local events=$(sed -n "s/Events shown:[[:blank:]]*//p" ${cg}.cachegrind | sed "s/ /,/g")

    printf "Src,Fn,Type," > ${results}/cachegrind.csv
    echo $events >> ${results}/cachegrind.csv

    for src in ${srcs[@]}; do
        cg=${results}/$(echo $src | sed "s/\.[^.]*$//")

        for fn in ${fns[@]}; do
            local data=$(cachegrind::process_fn ${cg}.cachegrind $fn)
            if [ -z $data ]; then continue; fi
            printf "${src},${fn},orig," >> ${results}/cachegrind.csv
            echo $data >> ${results}/cachegrind.csv

            data=$(cachegrind::process_fn ${cg}_opt.cachegrind $fn)
            printf "${src},${fn},orig-opt," >> ${results}/cachegrind.csv
            echo $data >> ${results}/cachegrind.csv

            data=$(cachegrind::process_fn ${cg}_inv.cachegrind $fn)
            printf "${src},${fn},invar," >> ${results}/cachegrind.csv
            echo $data >> ${results}/cachegrind.csv

            data=$(cachegrind::process_fn ${cg}_invopt.cachegrind $fn)
            printf "${src},${fn},invar-opt," >> ${results}/cachegrind.csv
            echo $data >> ${results}/cachegrind.csv
        done
    done
}

# Takes the path to a benchmark and runs the cachegrind tool on each binary
# inside a "bin" folder (generated by build.sh).
cachegrind::run() {
    local bench=$1;

    local bin=${bench}/bin
    local results=${bench}/results

    # Create results folder if it doesn't exist.
    mkdir -p $results

    # Parse the meta.yaml file to extract the cache configuration.
    local -A meta
    yaml::parse ${bench}/meta.yaml meta
    local -a cache=($(echo ${meta[cache]//,/ } | sed "s/;/,/g"))

    # Run cachegrind on each generated executable in order to check the number
    # of instructions executed, and measure cache-hits and cache-misses.
    for binname in $(ls $bin); do
        valgrind --tool=cachegrind ${cache[0]} ${cache[1]} ${cache[2]} \
            --cachegrind-out-file=tmp.cachegrind "${bin}/${binname}" &> /dev/null
        cg_annotate --threshold=0 tmp.cachegrind > "${results}/${binname}.cachegrind"
    done

    rm tmp.cachegrind
}
