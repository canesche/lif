#!/usr/bin/env bash

# Take the path to a cachegrind file generated by cg_annotate, the name
# of a source file and the function to be processed, and extract the general
# stats about that function.
cachegrind::process_fn() {
    local cg=$1
    local src=$2
    local fn=$3

    sed -n "/${src}:${fn}$/ s/\/.*//p" ${cg} \
        | sed "s/([^)]*)//g" \
        | sed "s/^[[:blank:]]*//" \
        | sed "s/[[:blank:]]*$//" \
        | sed "s/,/./g" \
        | sed -E "s/[[:blank:]]+/,/g"
}

# Takes the path to a benchmark plus a list of functions (comma-sepparated
# string)and filter the cachegrind stats collected by cachegrind::run to
# produce CSV files containing the results for specific functions. This
# function assumes the existence of three cachegrind files (generated by
# cg_annotate) for each source file (original, invariant and invar-optimized).
cachegrind::filter() {
    local bench=$1;
    local fns=$2;

    local results=${bench}/results
    local sources=${bench}/sources

    local -a srclist=($(ls $sources))
    # We assume that the collected evens are the same for all sources, so we
    # can take them from cachegrind file related to the first source.
    local cg=${results}/$(echo ${srclist[0]} | sed "s/\.[^.]*$//")
    local ext=cachegrind
    local events=$(sed -n "s/Events shown:[[:blank:]]*//p" ${cg}.${ext} | sed "s/ /,/g")

    printf "Src,Fn,Type," > ${results}/cachegrind.csv
    echo $events >> ${results}/cachegrind.csv

    for src in ${srclist[@]}; do
        cg=${results}/$(echo $src | sed "s/\.[^.]*$//")

        for fn in ${fns[@]}; do
            local data=$(cachegrind::process_fn ${cg}.${ext} $src $fn)
            printf "${src},${fn},orig," >> ${results}/cachegrind.csv
            echo $data >> ${results}/cachegrind.csv

            data=$(cachegrind::process_fn ${cg}_inv.${ext} $src $fn)
            printf "${src},${fn},invar," >> ${results}/cachegrind.csv
            echo $data >> ${results}/cachegrind.csv

            data=$(cachegrind::process_fn ${cg}_invopt.${ext} $src $fn)
            printf "${src},${fn},invar-opt," >> ${results}/cachegrind.csv
            echo $data >> ${results}/cachegrind.csv
        done
    done
}

# Takes the path to a benchmark and runs the cachegrind tool on each binary
# inside a "bin" folder (generated by build.sh).
cachegrind::run() {
    local bench=$1;

    local bin=${bench}/bin
    local results=${bench}/results

    # Create results folder if it doesn't exist.
    mkdir -p $results

    # Run cachegrind on each generated executable in order to check the number
    # of instructions executed, and measure cache-hits and cache-misses. We
    # define the config for both the L1 and LL caches as: 128 B, 32 B per line,
    # and associativity = 2.
    for name in $(ls $bin); do
        valgrind --tool=cachegrind --I1=128,2,32 --D1=128,2,32 --LL=128,2,32 \
            --cachegrind-out-file=tmp.cachegrind "${bin}/${name}" &> /dev/null
        cg_annotate --threshold=0 tmp.cachegrind > "${results}/${name}.cachegrind"
    done

    rm tmp.cachegrind
}
