module Core.Lang
    ( Label
    , Const
    , Var
    , Value(..)
    , Expr(..)
    , Inst(..)
    , Stm
    , Prog
    , IVar(..)
    , isControl
    , labelFrom
    , showStm
    , showProg
    , prefix
    , next
    , dv
    )
where

import           Prelude                 hiding ( and )

type Label = String
type Const = Integer
type Var = String

data Expr = Value Value
          | Neg Value
          | Not Value
          | Value :+: Value
          | Value :-: Value
          | Value :*: Value
          | Value :|: Value
          | Value :&: Value
          | Value :=: Value
          | Value :!=: Value
          | Value :<: Value
          | Value :>: Value
          | Value :<=: Value
          | Value :>=: Value
          deriving (Eq, Ord)

instance Show Expr where
    show (Value v   ) = show v
    show (Neg   v   ) = "-" ++ show v
    show (Not   v   ) = "!" ++ show v
    show (v1 :+:  v2) = show v1 ++ " + " ++ show v2
    show (v1 :-:  v2) = show v1 ++ " - " ++ show v2
    show (v1 :*:  v2) = show v1 ++ " * " ++ show v2
    show (v1 :|:  v2) = show v1 ++ " | " ++ show v2
    show (v1 :&:  v2) = show v1 ++ " & " ++ show v2
    show (v1 :=:  v2) = show v1 ++ " = " ++ show v2
    show (v1 :!=: v2) = show v1 ++ " != " ++ show v2
    show (v1 :<:  v2) = show v1 ++ " < " ++ show v2
    show (v1 :>:  v2) = show v1 ++ " > " ++ show v2
    show (v1 :<=: v2) = show v1 ++ " <= " ++ show v2
    show (v1 :>=: v2) = show v1 ++ " >= " ++ show v2

data Inst = Alloc Var Expr
          | Mov Var Expr
          | Load Var Expr
          | Store Expr Expr
          | Phi  Var [(Label, Value)]
          | Jmp  Label
          | Br  Value Label Label
          | Out Expr
          deriving (Eq, Ord)

instance Show Inst where
    show (Alloc x  e  ) = "alloc(" ++ x ++ ", " ++ show e ++ ")"
    show (Mov   x  e  ) = "mov(" ++ x ++ ", " ++ show e ++ ")"
    show (Load  x  e  ) = "load(" ++ x ++ ", " ++ show e ++ ")"
    show (Store e1 e2 ) = "store(" ++ show e1 ++ ", " ++ show e2 ++ ")"
    show (Phi   x  phi) = "phi(" ++ x ++ ", " ++ selectors phi ++ ")"
      where
        selectors :: [(Label, Value)] -> String
        selectors [(l, v)      ] = show v ++ ": " ++ l
        selectors ((l, v) : phi) = show v ++ ": " ++ l ++ ", " ++ selectors phi
    show (Jmp l     ) = "jmp(" ++ l ++ ")"
    show (Br e l1 l2) = "br(" ++ show e ++ ", " ++ l1 ++ ", " ++ l2 ++ ")"
    show (Out e     ) = "out(" ++ show e ++ ")"

type Stm = (Maybe Label, Inst)
type Prog = [Stm]

-- | Implicit var, generated by the interpreter.
newtype IVar = IVar Int deriving Eq
instance Show IVar where
    show (IVar n) = prefix ++ show n

data Value = Const Const | Var Var deriving (Eq, Ord)
instance Show Value where
    show (Const n) = show n
    show (Var   x) = x

isControl :: Inst -> Bool
isControl i@Jmp{} = True
isControl i@Br{}  = True
isControl _       = False

labelFrom :: [Inst] -> [Label]
labelFrom []                  = []
labelFrom ((Jmp l     ) : is) = l : labelFrom is
labelFrom ((Br _ l1 l2) : is) = l1 : l2 : labelFrom is
labelFrom (_            : is) = labelFrom is

showStm :: Stm -> String
showStm (Nothing, i) = show i ++ "\n"
showStm (Just l , i) = l ++ ": " ++ show i ++ "\n"

showProg :: Prog -> String
showProg = concatMap showStm

-- | Prefix added to labels/vars generated by the interpreter.
prefix :: String
prefix = "%"

next :: IVar -> IVar
next (IVar t) = IVar $ t + 1

dv :: [Inst] -> [Value]
dv []                 = []
dv (Alloc id _  : is) = Var id : dv is
dv (Mov   id _  : is) = Var id : dv is
dv (Load  id __ : is) = Var id : dv is
dv (Phi   id _  : is) = Var id : dv is
dv (_           : is) = dv is
